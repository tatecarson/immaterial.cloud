{"id":"node_modules/rhythmical/lib/Rhythm.js","dependencies":[{"name":"/Users/tatecarson/webDev/vibration-music/granular/package.json","includedInParent":true,"mtime":1585839294072},{"name":"/Users/tatecarson/webDev/vibration-music/granular/node_modules/rhythmical/package.json","includedInParent":true,"mtime":1585579120469},{"name":"./Fractions","loc":{"line":1,"column":26},"parent":"/Users/tatecarson/webDev/vibration-music/granular/node_modules/rhythmical/lib/Rhythm.js","resolved":"/Users/tatecarson/webDev/vibration-music/granular/node_modules/rhythmical/lib/Fractions.js"},{"name":"./Music","loc":{"line":2,"column":23},"parent":"/Users/tatecarson/webDev/vibration-music/granular/node_modules/rhythmical/lib/Rhythm.js","resolved":"/Users/tatecarson/webDev/vibration-music/granular/node_modules/rhythmical/lib/Music.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Rhythm = void 0;\n\nvar _Fractions = require(\"./Fractions\");\n\nvar _Music = require(\"./Music\");\n\nclass Rhythm {\n  static from(body) {\n    if (!Array.isArray(body)) {\n      return [body];\n    }\n\n    return body;\n  }\n\n  static duration(path, whole = 1) {\n    return path.reduce((f, p) => f / p[1] * (p[2] || 1), whole);\n  }\n\n  static time(path, whole = 1) {\n    return path.reduce(({\n      f,\n      t\n    }, p, i) => ({\n      f: f / p[1] * (p[2] || 1),\n      t: t + f / p[1] * path[i][0]\n    }), {\n      f: whole,\n      t: 0\n    }).t;\n  }\n\n  static oldDuration(divisions, whole = 1) {\n    return divisions.reduce((f, d) => f / d, whole);\n  }\n\n  static oldTime(divisions, path, whole = 1) {\n    return divisions.reduce(({\n      f,\n      p\n    }, d, i) => ({\n      f: f / d,\n      p: p + f / d * path[i]\n    }), {\n      f: whole,\n      p: 0\n    }).p;\n  }\n\n  static addPaths(a, b, divisions) {\n    // console.warn('addPaths is deprecated');\n    [a, b] = [a, b].sort((a, b) => b.length - a.length);\n    const added = a.map((n, i) => n + (b[i] || 0));\n\n    if (!divisions) {\n      return added;\n    }\n\n    return Rhythm.overflow(added, divisions);\n  }\n  /** recalculates path inside given divisions */\n\n\n  static overflow(path, divisions) {\n    path = [].concat(path);\n\n    for (let i = path.length - 1; i > 0; --i) {\n      if (path[i] >= divisions[i]) {\n        const rest = Math.floor(path[i] / divisions[i]);\n        path[i] = path[i] % divisions[i];\n        path[i - 1] += rest; // todo what happens if rest is too much for path[i-1]\n      }\n    }\n\n    return path;\n  }\n\n  static calculate(totalLength = 1) {\n    return ({\n      time,\n      duration,\n      path,\n      value,\n      length\n    }) => {\n      if (typeof value === 'number') {\n        length = value;\n      } else if (typeof value === 'object' && value['length']) {\n        length = value['length'];\n      } else {\n        length = 1;\n      }\n\n      return {\n        value,\n        path,\n        time: time !== undefined ? time : Rhythm.time(path, totalLength),\n        duration: duration !== undefined ? duration : Rhythm.duration(path, totalLength) * length\n      };\n    };\n  }\n\n  static useValueAsDuration(event) {\n    return Object.assign(Object.assign({}, event), {\n      duration: event.duration * event.value\n    });\n  }\n\n  static useValueAsLength(event) {\n    return Object.assign(Object.assign({}, event), {\n      length: event.value\n    });\n  }\n\n  static poly(rhythms, length = 1) {\n    const toArray = r => !Array.isArray(r) ? [r] : r;\n\n    return rhythms.reduce((events, rhythm) => events.concat(Rhythm.render(toArray(rhythm), length, true)), []);\n  }\n\n  static render(rhythm, length = 1, poly = false) {\n    return Rhythm.flat(rhythm, [], poly).map(Rhythm.calculate(length)).filter(event => !!event.duration);\n  }\n\n  static spm(bpm, pulse) {\n    return 60 / bpm * pulse;\n  }\n  /** Flattens the given possibly nested tree array to an array containing all values in sequential order.\n   * You can then turn RhythmEvent[] back to the original nested array with Measure.expand. */\n\n\n  static flatten(tree, path = [], divisions = []) {\n    if (!Array.isArray(tree)) {\n      // is primitive value\n      return [{\n        path,\n        divisions,\n        value: tree\n      }];\n    }\n\n    return tree.reduce((flat, item, index) => flat.concat(Rhythm.flatten(item, path.concat([index]), divisions.concat([tree.length]))), []);\n  }\n\n  static isValid(items) {\n    return items.reduce((valid, item) => {\n      return valid && item.divisions && item.path && item.divisions.length === item.path.length;\n    }, true);\n  }\n\n  static nest(items, fill = 0) {\n    return items.reduce((nested, item) => {\n      if (item.path[0] >= item.divisions[0]) {\n        console.error(`invalid path ${item.path[0]} in divisions ${item.divisions[0]} on item`, item);\n        return nested;\n      }\n\n      if (item.path.length !== item.divisions.length) {\n        console.error('invalid flat rhythm: different length of path / divisions', item);\n        return nested;\n      }\n\n      if (nested.length && nested.length < item.divisions[0]) {\n        console.error('ivalid flat rhythm: different divisions on same level > concat', items, nested);\n        nested = nested.concat(Array(item.divisions[0] - nested.length).fill(fill));\n        /* return nested; */\n      }\n\n      if (nested.length && nested.length > item.divisions[0]) {\n        console.warn('flat rhythm: different divisions on same level', items, nested);\n      }\n\n      if (!nested.length && item.divisions[0]) {\n        nested = new Array(item.divisions[0]).fill(fill);\n      }\n\n      if (item.path.length === 1) {\n        /* if (expanded[item.path[0]] !== undefined) {\n          if (!!expanded[item.path[0]]) {\n            return expanded; // dont override if already not 0\n          }\n          console.warn('override path ', item.path[0], ':', expanded[item.path[0]], 'with', item.value);\n        } */\n        if (Math.round(item.path[0]) === item.path[0]) {\n          nested[item.path[0]] = item.value;\n        } else if (item.value !== fill) {// console.warn('fractured path! value \"' + item.value + '\" !== \"' + fill + '\"', item)\n        }\n      } else {\n        nested[item.path[0]] = Rhythm.nest(items.filter(i => i.path.length > 1 && i.path[0] === item.path[0]).map(i => Object.assign(Object.assign({}, i), {\n          path: i.path.slice(1),\n          divisions: i.divisions.slice(1)\n        })), fill);\n      }\n\n      return nested;\n    }, []);\n  }\n  /** Turns a flat FlatEvent array to a (possibly) nested Array of its values. Reverts Measure.flatten. */\n\n\n  static expand(items) {\n    console.warn('expand is deprecated');\n    let lastSiblingIndex = -1;\n    return items.reduce((expanded, item, index) => {\n      if (item.path.length === 1) {\n        expanded[item.path[0]] = item.value;\n      } else if (item.path[0] > lastSiblingIndex) {\n        lastSiblingIndex = item.path[0];\n        const siblings = items.filter((i, j) => j >= index && i.path.length >= item.path.length).map(i => Object.assign(Object.assign({}, i), {\n          path: i.path.slice(1)\n        }));\n        expanded[item.path[0]] = Rhythm.expand(siblings);\n      }\n\n      return expanded;\n    }, []);\n  }\n\n  static pathOf(value, tree) {\n    const flat = Rhythm.flatten(tree);\n    const match = flat.find(v => v.value === value);\n\n    if (match) {\n      return match.path;\n    }\n  }\n\n  static simplePath(path) {\n    return path.join('.').replace(/(\\.0)*$/, ''); //.split('.');\n  }\n\n  static haveSamePath(a, b) {\n    return Rhythm.simplePath(a.path) === Rhythm.simplePath(b.path);\n  }\n\n  static haveSameSlot(a, b) {\n    return Rhythm.simplePath(a.path) === Rhythm.simplePath(b.path) && Rhythm.simplePath(a.divisions) === Rhythm.simplePath(b.divisions); //a.divisions.length === b.divisions.length\n  }\n\n  static getPath(tree, path, withPath = false, flat) {\n    if (typeof path === 'number') {\n      path = [path];\n    }\n\n    flat = flat || Rhythm.flatten(tree);\n    const match = flat.find(v => {\n      const min = Math.min(path.length, v.path.length);\n      return v.path.slice(0, min).join(',') === path.slice(0, min).join(',');\n    });\n\n    if (withPath) {\n      return match;\n    }\n\n    return match ? match.value : undefined;\n  }\n\n  static addPulse(rhythm, pulse, offset = 0) {\n    const measures = Math.ceil(rhythm.length / pulse);\n    return Rhythm.nest(Rhythm.flatten(rhythm).map(({\n      value,\n      divisions,\n      path\n    }) => {\n      divisions = [measures].concat([pulse], divisions.slice(1));\n      path = [Math.floor(path[0] / pulse)].concat([path[0] % pulse], path.slice(1));\n      path = offset ? Rhythm.addPaths(path, [0, offset], divisions) : path;\n      return {\n        value,\n        divisions,\n        path\n      };\n    }));\n  }\n  /* static addPulses<T>(rhythm: NestedRhythm<T>, pulses: number[], offset: number = 0): NestedRhythm<T> {\n    return Rhythm.nest(\n      Rhythm.flatten(rhythm).map(({ value, divisions, path }) => {\n        // const pulse = divisions[1] || 1;\n        const pulse = path[0]\n        const measures = Math.ceil(rhythm.length / pulse);\n        divisions = [measures].concat([pulse], divisions.slice(1));\n        path = [Math.floor(path[0] / pulse)].concat([path[0] % pulse], path.slice(1));\n        path = offset ? Rhythm.addPaths(path, [0, offset], divisions) : path;\n        return {\n          value,\n          divisions,\n          path\n        }\n      })\n    );\n  } */\n\n\n  static removePulse(rhythm) {\n    return Rhythm.nest(Rhythm.flatten(rhythm).map(({\n      value,\n      divisions,\n      path\n    }) => ({\n      value,\n      divisions: [divisions[1] * divisions[0]].concat(divisions.slice(2)),\n      path: [path[0] * divisions[1] + path[1]].concat(path.slice(2))\n    })));\n  }\n\n  static nextItem(tree, path, move = 1, withPath = false, flat) {\n    flat = Rhythm.flatten(tree);\n    const match = Rhythm.getPath(tree, path, true, flat);\n\n    if (match) {\n      let index = (flat.indexOf(match) + move + flat.length) % flat.length;\n\n      if (withPath) {\n        return flat[index];\n      }\n\n      return flat[index] ? flat[index].value : undefined;\n    }\n  }\n\n  static nextValue(tree, value, move = 1) {\n    const flat = Rhythm.flatten(tree);\n    const match = flat.find(v => v.value === value);\n\n    if (match) {\n      return Rhythm.nextItem(tree, match.path, move, false, flat);\n    }\n  }\n\n  static nextPath(tree, path, move = 1) {\n    const flat = Rhythm.flatten(tree);\n\n    if (!path) {\n      return flat[0] ? flat[0].path : undefined;\n    }\n\n    const match = Rhythm.getPath(tree, path, true, flat);\n\n    if (match) {\n      const next = Rhythm.nextItem(tree, match.path, move, true, flat);\n      return next ? next.path : undefined;\n    }\n  }\n\n  static getBlock(length, position, pulse = 4) {\n    const blocks = {\n      4: [4],\n      2: position === 0 ? [2, 0] : [0, 2] // or any other 2 block\n\n      /** ... */\n\n    };\n    Array(position).fill(0).concat(blocks[length]).concat(Array(pulse - position - length).fill(0));\n    return blocks[length];\n  }\n\n  addGroove(items, pulse = 4) {\n    const chordsPerBeat = pulse / items.length;\n\n    if (chordsPerBeat < 0) {// need another grid... or just error??\n    }\n\n    if (Math.round(chordsPerBeat) !== chordsPerBeat) {// apply bjorklund to fill chords evenly\n    }\n\n    const rendered = Rhythm.render(items, pulse);\n    let time = 0;\n    return rendered.reduce((combined, chordEvent, index) => {\n      // const time = rendered.slice(0, index + 1).reduce((sum, track) => sum + track.duration, 0);\n      combined = Object.assign(Object.assign({}, combined), {\n        [chordEvent.value]: Rhythm.getBlock(chordEvent.duration, time)\n      });\n      time += chordEvent.duration;\n      return combined;\n    }, {});\n  }\n  /**\n   * NEW SYNTAX\n   */\n\n\n  static multiplyDivisions(divisions, factor) {\n    return [divisions[0] * factor].concat(divisions.slice(1));\n  }\n\n  static multiplyPath(path, divisions, factor) {\n    path = path.map(v => factor * v);\n    return Rhythm.overflow(path, divisions);\n  }\n\n  static multiplyEvents(rhythm, factor) {\n    return Rhythm.fixTopLevel(rhythm.map(({\n      value,\n      path\n    }) => ({\n      value: value * factor,\n      path: Rhythm.carry(path.map((f, i) => [f[0] * factor, f[1] * (!i ? factor : 1) // f[1] * factor\n      // f[1]\n      ]))\n    })));\n  }\n\n  static divideEvents(rhythm, factor) {\n    return Rhythm.multiplyEvents(rhythm, 1 / factor);\n  }\n\n  static multiply(rhythm, factor) {\n    return Rhythm.nested(Rhythm.multiplyEvents(Rhythm.flat(rhythm), factor));\n  }\n\n  static divide(rhythm, divisor) {\n    return Rhythm.multiply(rhythm, 1 / divisor);\n  }\n\n  static maxArray(array) {\n    if (!array || !array.length) {\n      return;\n    }\n\n    return array.reduce((max, item) => Math.max(max, item), array[0]);\n  }\n  /* static countChildren(item, poly = false) {\n    if (item[params.monophony]) {\n      return item[params.monophony].length * item['duration'][0] + 1;\n    }\n    return sum + item['duration'][0];\n  } */\n\n  /** Flattens the given possibly nested tree array to an array containing all values in sequential order.\n   * You can then turn RhythmEvent[] back to the original nested array with Measure.expand. */\n\n\n  static flat(rhythm, path = [], poly = false, props = []) {\n    // get total duration of rhythm\n    let duration;\n\n    if (!poly) {\n      duration = rhythm.reduce((sum, item) => {\n        if (Array.isArray(item) || typeof item !== 'object') {\n          return sum + 1;\n        }\n\n        if (Array.isArray(item['duration'])) {\n          if (item[_Music.params.monophony]) {\n            item['duration'] = item[_Music.params.monophony].length * item['duration'][0]; //return sum + item['duration'];\n          } else if (item[_Music.params.polyphony]) {\n            item['duration'] = item['duration'][0]; // poly\n          } else {\n            item['duration'] = item['duration'][0]; // poly\n          }\n        }\n\n        return sum + (item['duration'] !== undefined ? item['duration'] : 1);\n      }, 0);\n    } else {\n      duration = 1;\n    }\n\n    let time = 0;\n    return rhythm.reduce((flat, item, index) => {\n      const i = time + (item['time'] || 0);\n\n      if (!poly) {\n        time += typeof item === 'object' ? +(item['duration'] || 1) : 1;\n      }\n\n      if (typeof item === 'object') {\n        const collectedKeys = ['voice', 'duration'];\n        Object.keys(item).filter(key => collectedKeys.includes(key)).forEach(key => {\n          props[key] = [item[key]].concat(props[key] || []);\n        });\n      } else {\n        props = Object.keys(props).reduce((p, key) => Object.assign(Object.assign({}, p), {\n          [key]: [null].concat(props[key])\n        }), props);\n      }\n\n      if (!Array.isArray(item)) {\n        if (props['duration'] && Array.isArray(props['duration'][0])) {\n          item['duration'] = props['duration'][0][0] || 1;\n          /* console.log(`item duration ${newDuration}/${duration}`, item); */\n        }\n\n        return flat.concat([{\n          value: item,\n          path: path.concat([[i, duration, item['duration'] || 1]])\n        }]);\n      }\n\n      return flat.concat(Rhythm.flat(item, path.concat([[i, duration]]), poly, props)\n      /* Rhythm.flat(item, path.concat([[index, rhythm.length]])) */\n      );\n    }, []);\n  }\n\n  static nested(items, fill = 0) {\n    return items.reduce((nested, item) => {\n      if (item.path[0][0] >= item.path[0][1]) {\n        console.error(`invalid path ${item.path[0]} on item`, item);\n        return nested;\n      }\n\n      if (nested.length && nested.length < item.path[0][1]) {\n        console.warn('ivalid flat rhythm: different divisions on same level > concat', items, nested);\n        nested = nested.concat(Array(item.path[0][1] - nested.length).fill(fill));\n        /* return nested; */\n      }\n\n      if (nested.length && nested.length > item.path[0][1]) {\n        console.warn('flat rhythm: different divisions on same level', items, nested);\n      }\n\n      if (!nested.length && item.path[0][1]) {\n        nested = new Array(item.path[0][1]).fill(fill);\n      }\n\n      if (item.path.length === 1) {\n        if (Math.round(item.path[0][0]) === item.path[0][0]) {\n          nested[item.path[0][0]] = item.value;\n        } else if (item.value !== fill) {\n          console.warn('fractured path! value \"' + item.value + '\" !== \"' + fill + '\"', item);\n        }\n      } else {\n        nested[item.path[0][0]] = Rhythm.nested(items.filter(i => i.path.length > 1 && i.path[0][0] === item.path[0][0]).map(i => Object.assign(Object.assign({}, i), {\n          path: i.path.slice(1)\n        })), fill);\n      }\n\n      return nested;\n    }, []);\n  } // aligns all paths to longest path length, filling each up with [0, 1]\n\n\n  static align(...paths) {\n    return paths.map(p => p.concat(Array(Rhythm.maxArray(paths.map(p => p.length)) - p.length).fill([0, 1])));\n  } // carries all fractions that are >=1 over to the next fraction to mimic notated rhythm behaviour\n\n\n  static carry(a) {\n    a = [].concat(a);\n\n    for (let i = a.length - 1; i > 0; --i) {\n      a[i - 1][0] += Math.floor(a[i][0] / a[i][1]);\n      a[i][0] = a[i][0] % a[i][1];\n    }\n\n    a[0][1] = Math.max(a[0][0] + 1, a[0][1]);\n    return a;\n  }\n\n  static add(a, b, cancel = false) {\n    [a, b] = Rhythm.align(a, b);\n    return Rhythm.carry(a.map((f, i) => _Fractions.Fractions.add(f, b[i], cancel)));\n  }\n\n  static fixTopLevel(events) {\n    // find max divisor on top level\n    const max = Rhythm.maxArray(events.map(e => e.path[0][1])); // use max divisor for all top levels\n\n    return events.map(e => Object.assign(Object.assign({}, e), {\n      path: e.path.map((f, i) => !i ? [f[0], max] : f)\n    }));\n  }\n  /* Makes sure the top level is correct on all events + adds optional path to move the events */\n\n\n  static shiftEvents(events, path) {\n    if (path) {\n      events = events.map(e => Object.assign(Object.assign({}, e), {\n        path: Rhythm.add(e.path, path)\n      }));\n    }\n\n    return Rhythm.fixTopLevel(events).filter(e => !!e.value);\n  }\n\n  static shift(rhythm, path) {\n    return Rhythm.nested(Rhythm.shiftEvents(Rhythm.flat(rhythm), path));\n  }\n\n  static groupEvents(events, pulse, offset) {\n    let wrapped = events.map(({\n      value,\n      path\n    }) => {\n      path = [].concat([[Math.floor(path[0][0] / pulse), Math.ceil(path[0][1] / pulse)]], [[path[0][0] % pulse, pulse]], path.slice(1));\n      return {\n        value,\n        path\n      };\n    });\n\n    if (offset) {\n      wrapped = Rhythm.shiftEvents(wrapped, [[0, 1], [offset, pulse]]);\n    }\n\n    return wrapped;\n  }\n\n  static group(rhythm, pulse, offset) {\n    return Rhythm.nested(Rhythm.groupEvents(Rhythm.flat(rhythm), pulse, offset));\n  }\n\n  static ungroupEvents(events) {\n    return events.map(({\n      value,\n      path\n    }) => ({\n      value,\n      path: [[path[0][0] * path[1][1] + path[1][0], path[1][1] * path[0][1]]].concat(path.slice(2))\n    }));\n  }\n\n  static ungroup(rhythm) {\n    return Rhythm.nested(Rhythm.ungroupEvents(Rhythm.flat(rhythm)));\n  }\n\n  static combine(source, target) {\n    let targetEvents = Rhythm.flat(target);\n    let sourceEvents = Rhythm.flat(source);\n\n    if (source.length > target.length) {\n      targetEvents = Rhythm.shiftEvents(Rhythm.flat(target), [[0, source.length]]); // add empty bars\n    } else if (target.length > source.length) {\n      sourceEvents = Rhythm.shiftEvents(Rhythm.flat(source), [[0, target.length]]); // add empty bars\n    }\n\n    return Rhythm.nested(Rhythm.combineEvents(targetEvents, sourceEvents));\n  }\n\n  static combineEvents(a, b) {\n    return Rhythm.shiftEvents([].concat(a, b).filter(e => !!e.value));\n  }\n\n  static isEqualPath(a, b) {\n    const paths = Rhythm.align(a, b).map(p => JSON.stringify(p));\n    return paths[0] === paths[1];\n  }\n\n  static insertEvents(sourceEvents, targetEvents, beat) {\n    const pulses = targetEvents.map(e => e.path[1] ? e.path[1][1] : 1);\n    const beats = targetEvents[0].path[0][1] * pulses[0];\n\n    if (beat === undefined) {\n      beat = beats; // set to end if undefined\n    } else if (beat < 0) {\n      beat = beats + beat; // subtract from end\n    } // handle negative offset\n\n\n    sourceEvents = Rhythm.groupEvents(sourceEvents, pulses[0], beat);\n    return Rhythm.combineEvents(targetEvents, sourceEvents);\n  }\n\n  static insert(source, target, beat) {\n    return Rhythm.nested(Rhythm.insertEvents(Rhythm.flat(source), Rhythm.flat(target), beat));\n  }\n\n  static migratePath(divisions, path) {\n    return divisions.map((d, index) => [path ? path[index] : 0, d]);\n  }\n\n}\n/*\n\n\nstatic normalize(a: RhythmEvent<number>, depth) {\n  const diff = depth - a.path.length;\n  if (diff > 0) { // gets longer\n    return {\n      value: a.value,\n      path: a.path.concat(Array(diff).fill(0)),\n      divisions: a.divisions.concat(Array(diff).fill(1)),\n    }\n  }\n  // const divisions = a.divisions.slice(0, depth);\n  return {\n    value: a.value * Rhythm.duration(a.divisions),\n    path: a.path.slice(0, depth),\n    divisions: a.divisions.slice(0, depth)\n  }\n} */\n\n/*\n\n  static f<T>(source: NestedRhythm<T>, target: NestedRhythm<T>, offset = 0) {\n    let targetEvents = Rhythm.flatten(target);\n    const pulses = targetEvents.map(e => e.divisions[1] || 1);\n    source = Rhythm.addPulse(source, pulses[0], offset);\n\n    const targetLength = source.length;\n    if (targetLength >= target.length) {\n      const fill = targetLength - target.length;\n      target = target.concat(Array(fill).fill(0));\n    }\n    targetEvents = Rhythm.flatten(target);\n    const sourceEvents = Rhythm.flatten(source)\n      .map(event => ({ ...event, divisions: [target.length].concat(event.divisions.slice(1)) }))\n      .filter(event => !!event.value || !targetEvents.find(e => Rhythm.haveSameSlot(e, event)))\n      .map(event => ({ ...event, path: Rhythm.overflow(event.path, event.divisions) }));\n    return Rhythm.nest(targetEvents.concat(sourceEvents));\n  }\n\n  static merge<T>(source: NestedRhythm<T>, target: NestedRhythm<T>, path = [0]) {\n    const targetLength = source.length + path[0];\n    if (targetLength >= target.length) {\n      const fill = targetLength - target.length;\n      target = target.concat(Array(fill).fill(0));\n    }\n    const targetEvents = Rhythm.flatten(target);\n    const sourceEvents = Rhythm.flatten(source)\n      .map(event => ({ ...event, divisions: [target.length].concat(event.divisions.slice(1)) }))\n      .filter(event => !!event.value || !targetEvents.find(e => Rhythm.haveSameSlot(e, event)))\n      .map(event => ({ ...event, path: Rhythm.addPaths(path, event.path, event.divisions) }));\n\n    return Rhythm.nest(targetEvents.concat(sourceEvents));\n  }\n  */\n\n\nexports.Rhythm = Rhythm;","map":null},"hash":"1dbaf97c1bcae1613ea106e332974ac3","cacheData":{"env":{}}}