{"id":"../node_modules/rhythmical/lib/Music.js","dependencies":[{"name":"/Users/tatecarson/webDev/vibration-music/granular/package.json","includedInParent":true,"mtime":1586051670864},{"name":"/Users/tatecarson/webDev/vibration-music/granular/node_modules/rhythmical/package.json","includedInParent":true,"mtime":1585579120469},{"name":"./Rhythm","loc":{"line":1,"column":23},"parent":"/Users/tatecarson/webDev/vibration-music/granular/node_modules/rhythmical/lib/Music.js","resolved":"/Users/tatecarson/webDev/vibration-music/granular/node_modules/rhythmical/lib/Rhythm.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toObject = toObject;\nexports.toArray = toArray;\nexports.unify = unify;\nexports.render2 = render2;\nexports.calculate2 = calculate2;\nexports.isSameSlot = isSameSlot;\nexports.eventDuration = eventDuration;\nexports.flat2 = flat2;\nexports.params = void 0;\n\nvar _Rhythm = require(\"./Rhythm\");\n\nconst params = {\n  monophony: 'm',\n  polyphony: 'p',\n  time: 'time',\n  duration: 'duration',\n  velocity: 'v'\n};\nexports.params = params;\n\nfunction toObject(music, param = params['monophony']) {\n  if (typeof music !== 'object' || Array.isArray(music)) {\n    return {\n      [param]: music\n    };\n  }\n\n  return music;\n}\n\nfunction toArray(array) {\n  if (!Array.isArray(array)) {\n    return [array];\n  }\n\n  return array;\n}\n\nfunction unify(music) {\n  const o = toObject(music);\n\n  if (o[params.monophony]) {\n    o[params.monophony] = toArray(o[params.monophony]);\n  }\n\n  if (o[params.polyphony]) {\n    o[params.polyphony] = toArray(o[params.polyphony]);\n  }\n\n  return o;\n}\n\nfunction render2(music, transform) {\n  const length = eventDuration(music);\n  /* const length =\n    typeof music === 'object' && !Array.isArray(music)\n      ? music['duration'] || 1\n      : 1; */\n  // The top level duration is special: it has no relational use => only one element at top\n  // => find way to use array notation with top level duration\n\n  let flat = flat2(music, {}, transform);\n  const p = flat.map(calculate2(length, false))\n  /* .map(e => {\n  const offset = Math.random() * error;\n  return {\n  ...e,\n  time: e.time + offset,\n  duration: e.duration - offset,\n  velocity: e.velocity - velocityError * Math.random(),\n  }\n  }) */\n  ;\n  const seconds = music['seconds'] || length; // ||length;\n\n  return {\n    seconds,\n    p\n  };\n}\n\nfunction calculate2(totalLength = 1, verbose = false) {\n  return e => {\n    let {\n      path,\n      m,\n      length,\n      velocity\n    } = e;\n    length = length || 1;\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, e), {\n      m\n    }), verbose ? e : {}), {\n      time: _Rhythm.Rhythm.time(path, totalLength),\n      velocity,\n      duration: _Rhythm.Rhythm.duration(path, totalLength) * length\n    });\n  };\n}\n\nfunction isSameSlot(pathsA, pathsB) {\n  if (!pathsA || !pathsB) {\n    return false;\n  }\n\n  const slotA = pathsA.map(p => p.join('.')).join('-');\n  const slotB = pathsB.map(p => p.join('.')).join('-');\n  return slotA === slotB;\n}\n\nfunction eventDuration(e, standard = 1) {\n  if (typeof e !== 'object') {\n    return standard;\n  }\n\n  if (Array.isArray(e.duration)) {\n    // TBD: fix implement proper duration array notation + more\n    // TBD: add possibility to pass duration further down\n    // TBD: use elvis operator\n    return (// TBD; dont use length => use durations!! \n      e.duration[0] * ((e[params.monophony] || []).length || 1) //e[params.polyphony].length\n\n    );\n  }\n\n  return e.duration || standard;\n}\n\nfunction flat2(music, props = {}, transform) {\n  let block = unify(music);\n\n  if (transform) {\n    const transformed = transform({\n      block,\n      props\n    });\n    block = transformed.block;\n    props = transformed.props;\n  } // TBD find way to use array duration notation with root of object\n  // drill props\n\n\n  props = Object.assign(Object.assign({}, props), {\n    length: (block.length || 1) * (props.length || 1),\n    velocity: (props.velocity === undefined ? 1 : props.velocity) * (block.velocity === undefined ? 1 : block.velocity),\n    instrument: block['instrument'] || props.instrument\n  }); // TBD remember which velocity was on which level? maybe map simplePath:velocity, same for length\n  // those props are merged into the rendered events / blocks (together with path)\n\n  const eventProps = {\n    velocity: props.velocity,\n    instrument: props.instrument,\n    length: props.length\n  };\n  const m = block[params.monophony] || [];\n  const p = block[params.polyphony] || [];\n  const mDuration = m.reduce((total, e) => total + eventDuration(e), 0);\n  const pDuration = p.reduce((max, e) => Math.max(max, eventDuration(e)), 0); // const pDuration = /* block.duration || */ 1;\n\n  const allEvents = [...m, ...p];\n  const stack = allEvents.reduce((state, event, i) => {\n    const isPoly = p.includes(event);\n    const eDuration = eventDuration(event); // remember: dont drill path here\n\n    const path = (props.path || []).concat([[isPoly ? event.time || 0 : state.time + (event.time || 0), isPoly ? pDuration : mDuration, eDuration, i]]);\n    return Object.assign(Object.assign({}, state), {\n      time: state.time + eDuration,\n      events: state.events.concat(typeof event === 'object' // is object? => go deeper, is primitve => stop\n      ? flat2(event, Object.assign(Object.assign({}, props), {\n        path\n      }), transform) : [Object.assign(Object.assign({\n        [params.monophony]: event\n      }, eventProps), {\n        path\n      })])\n    });\n  }, {\n    events: [],\n    time: 0,\n    duration: 0\n  });\n\n  if (props.path) {\n    stack.events.push(Object.assign({\n      block: '*',\n      path: props.path\n    }, eventProps));\n  }\n\n  return (props.events || []).concat(stack.events);\n}"},"sourceMaps":null,"error":null,"hash":"8bfcba0610d9ba05caa638a022d88a25","cacheData":{"env":{}}}